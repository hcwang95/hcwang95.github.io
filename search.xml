<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>[Missing Semester in CS] Editors (Vim)</title>
    <url>/2020/04/10/MSC-editors-vim/</url>
    <content><![CDATA[<p>Description: TODO</p>
<a id="more"></a>

<h2 id="Exercise"><a href="#Exercise" class="headerlink" title="Exercise"></a>Exercise</h2><ol>
<li><p>Complete <code>vimtutor</code>. Note: it looks best in a<br><a href="https://en.wikipedia.org/wiki/VT100" target="_blank" rel="noopener">80x24</a> (80 columns by 24 lines)<br>terminal window.</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> vimtutor</span></span><br></pre></td></tr></table></figure>
<p>Really fantasitc learning material. Also remember the notes inside the tutor file: <strong>You should be learning by doing, not memorization</strong>.</p>
</li>
<li><p>Download our <a href="https://missing.csail.mit.edu/2020/files/vimrc" target="_blank" rel="noopener">basic vimrc</a> and save it to <code>~/.vimrc</code>. Read<br>through the well-commented file (using Vim!), and observe how Vim looks and<br>behaves slightly differently with the new config.</p>
</li>
</ol>
<p>Just want to mention some great educational commands:</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">nnoremap</span> <span class="symbol">&lt;Left&gt;</span>  :<span class="keyword">echoe</span> <span class="string">"Use h"</span><span class="symbol">&lt;CR&gt;</span></span><br><span class="line"><span class="keyword">nnoremap</span> <span class="symbol">&lt;Right&gt;</span> :<span class="keyword">echoe</span> <span class="string">"Use l"</span><span class="symbol">&lt;CR&gt;</span></span><br><span class="line"><span class="keyword">nnoremap</span> <span class="symbol">&lt;Up&gt;</span>    :<span class="keyword">echoe</span> <span class="string">"Use k"</span><span class="symbol">&lt;CR&gt;</span></span><br><span class="line"><span class="keyword">nnoremap</span> <span class="symbol">&lt;Down&gt;</span>  :<span class="keyword">echoe</span> <span class="string">"Use j"</span><span class="symbol">&lt;CR&gt;</span></span><br></pre></td></tr></table></figure>
<p>Every time we want to use direction key, they will disable and tell us not to do that.</p>
<ol start="3">
<li>Install and configure a plugin:<br><a href="https://github.com/ctrlpvim/ctrlp.vim" target="_blank" rel="noopener">ctrlp.vim</a>.<ol>
<li>Create the plugins directory with <code>mkdir -p ~/.vim/pack/vendor/start</code></li>
<li>Download the plugin: <code>cd ~/.vim/pack/vendor/start; git clone
https://github.com/ctrlpvim/ctrlp.vim</code></li>
<li>Read the<br><a href="https://github.com/ctrlpvim/ctrlp.vim/blob/master/readme.md" target="_blank" rel="noopener">documentation</a><br>for the plugin. Try using CtrlP to locate a file by navigating to a<br>project directory, opening Vim, and using the Vim command-line to start<br><code>:CtrlP</code>.<ol>
<li>Customize CtrlP by adding<br><a href="https://github.com/ctrlpvim/ctrlp.vim/blob/master/readme.md#basic-options" target="_blank" rel="noopener">configuration</a><br>to your <code>~/.vimrc</code> to open CtrlP by pressing Ctrl-P.</li>
</ol>
</li>
</ol>
</li>
</ol>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> ~/.vim</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">clone</span> https://github.com/ctrlpvim/ctrlp.vim.git bundle/ctrlp.vim</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> vim ~/.vimrc <span class="comment"># setting the config in vimrc</span></span></span><br></pre></td></tr></table></figure>

<ol start="4">
<li>To practice using Vim, re-do the <a href="https://missing.csail.mit.edu/2020/editors/#demo" target="_blank" rel="noopener">Demo</a> from lecture on your own<br>machine.</li>
<li>Use Vim for <em>all</em> your text editing for the next month. Whenever something<br>seems inefficient, <strong>or when you think “there must be a better way”, try<br>Googling it, there probably is.</strong></li>
<li>Configure your other tools to use Vim bindings (see instructions above).</li>
</ol>
<p>Here is a <a href="https://www.ubuntupit.com/best-vim-plugins-for-programming/" target="_blank" rel="noopener">list</a> of commonly used plugins for vim user.</p>
<ol start="7">
<li>Further customize your <code>~/.vimrc</code> and install more plugins.</li>
<li>(Advanced) Convert XML to JSON (<a href="https://missing.csail.mit.edu/2020/files/example-data.xml" target="_blank" rel="noopener">example file</a>)<br>using Vim macros. Try to do this on your own, but you can look at the<br><a href="https://missing.csail.mit.edu/2020/editors/#macros" target="_blank" rel="noopener">macros</a> section above if you get stuck.</li>
</ol>
<p>Follow the instruction is enough to reproduce. And you will find it exciting when the editor programmably works for you. Completely reduce the repetition!</p>
]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>tool</tag>
        <tag>vim</tag>
      </tags>
  </entry>
  <entry>
    <title>[Missing Semester in CS] Shell scripting and tools</title>
    <url>/2020/04/05/MSC-shell-scripting/</url>
    <content><![CDATA[<h2 id="Brief"><a href="#Brief" class="headerlink" title="Brief"></a>Brief</h2><p>After going through the basic bash commands in the previous class, we will explore more in putting all sort of commands together into a bash script file. </p>
<p>There are a bunch of must-knows for writing the scripts introduced in the class. Here is the complete list to check if you all understand:</p>
<ul>
<li>variables assignment (NO SPACES!)</li>
<li>difference between strings enclosed with <code>&#39;</code> and <code>&quot;</code></li>
<li>control flows: <code>if</code>, <code>while</code>, <code>case</code>, <code>for</code></li>
<li>function definition, inputs, return value and some <a href="https://www.tldp.org/LDP/abs/html/special-chars.html" target="_blank" rel="noopener">special variables</a>.</li>
<li><code>&amp;&amp;</code> and <code>||</code> operators</li>
<li>get the outputs from a command</li>
<li><a href="http://man7.org/linux/man-pages/man1/test.1.html" target="_blank" rel="noopener">testing condition</a>, also mentioned in my last post.</li>
<li>wildcards(<code>foo*</code>) and curly brace(<code>foo.{jpg,png}</code>, <code>foo{a..h}</code>, <code>foo{1..100}</code>) for variables.</li>
<li><a href="https://github.com/koalaman/shellcheck" target="_blank" rel="noopener">shellcheck</a></li>
</ul>
<p>I would add the <a href="https://kvz.io/bash-best-practices.html" target="_blank" rel="noopener">artical</a> for some helpful bash settings. However I guess finding your own convention of writing / debugging bash script would be even helpful by adopting those conventions that fit for you.</p>
<p>Besides the techniques, several practical use cases are discussed, which might make our experience in writing bash less painful.</p>
<ul>
<li>find how to use command</li>
<li>find files</li>
<li>find / match codes</li>
<li>find previous used shell commands</li>
<li>faster directory navigation</li>
</ul>
<a id="more"></a>

<h2 id="Exercises"><a href="#Exercises" class="headerlink" title="Exercises"></a>Exercises</h2><ol>
<li><p>Read <a href="http://man7.org/linux/man-pages/man1/ls.1.html" target="_blank" rel="noopener"><code>man ls</code></a> and write an <code>ls</code> command that lists files in the following manner</p>
<ul>
<li><p>Includes all files, including hidden files</p>
</li>
<li><p>Sizes are listed in human readable format (e.g. 454M instead of 454279954)</p>
</li>
<li><p>Files are ordered by recency</p>
</li>
<li><p>Output is colorized</p>
<p>A sample output would look like this</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">-rw-r--r--   1<span class="built_in"> user group </span>1.1M Jan 14 09:53 baz</span><br><span class="line">drwxr-xr-x   5<span class="built_in"> user group </span> 160 Jan 14 09:53 .</span><br><span class="line">-rw-r--r--   1<span class="built_in"> user group </span> 514 Jan 14 06:42 bar</span><br><span class="line">-rw-r--r--   1<span class="built_in"> user group </span>106M Jan 13 12:12 foo</span><br><span class="line">drwx------+ 47<span class="built_in"> user group </span>1.5K Jan 12 18:08 <span class="built_in">..</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ol>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ls -lath --color=auto</span></span><br></pre></td></tr></table></figure>
<p>This is an example which requires us to understand more options from <code>ls</code>. In short, <code>-l</code> give LONG format, <code>-a</code> specifies to show ALL. <code>-t</code> means showing in TIME (recency) order. <code>-h</code> equals to <code>--human-readable</code>. <code>--color=auto</code> colorizes the output.<br> Usually the default in Ubuntu System, <code>ls</code> already refers to <code>ls --color=auto</code> for better visualization using <a href="http://linuxcommand.org/lc3_man_pages/aliash.html" target="_blank" rel="noopener">aliasing</a>. </p>
<ol start="2">
<li>Write bash functions  <code>marco</code> and <code>polo</code> that do the following.<br>Whenever you execute <code>marco</code> the current working directory should be saved in some manner, then when you execute <code>polo</code>, no matter what directory you are in, <code>polo</code> should <code>cd</code> you back to the directory where you executed <code>marco</code>.<br>For ease of debugging you can write the code in a file <code>marco.sh</code> and (re)load the definitions to your shell by executing <code>source marco.sh</code>.</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># bash variable setting and usage</span></span><br><span class="line"><span class="function"><span class="title">marco</span></span>() &#123;</span><br><span class="line">    <span class="built_in">export</span> MARCO=$(<span class="built_in">pwd</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">polo</span></span>() &#123;</span><br><span class="line">    <span class="built_in">cd</span> <span class="string">"<span class="variable">$MARCO</span>"</span> <span class="comment"># or cd $&#123;MARCO&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><p>Say you have a command that fails rarely. In order to debug it you need to capture its output but it can be time consuming to get a failure run.<br>Write a bash script that runs the following script until it fails and captures its standard output and error streams to files and prints everything at the end.<br>Bonus points if you can also report how many runs it took for the script to fail.</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env bash</span></span><br><span class="line"></span><br><span class="line">n=$(( RANDOM % 100 ))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [[ n -eq 42 ]]; <span class="keyword">then</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"Something went wrong"</span></span><br><span class="line">   &gt;&amp;2 <span class="built_in">echo</span> <span class="string">"The error was using magic numbers"</span></span><br><span class="line">   <span class="built_in">exit</span> 1</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"Everything went according to plan"</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env bash</span></span><br><span class="line"></span><br><span class="line">count=0</span><br><span class="line">until [[ <span class="string">"$?"</span> -ne 0 ]];</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  count=$((count+1))</span><br><span class="line">  ./random.sh &amp;&gt; out.txt</span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"found error after <span class="variable">$count</span> runs"</span></span><br><span class="line">cat out.txt</span><br></pre></td></tr></table></figure>

<p>Some points interesting to check:</p>
<p><code>n=$(( RANDOM % 100 ))</code><br>Check <a href="http://mywiki.wooledge.org/ArithmeticExpression" target="_blank" rel="noopener">math context</a> about how to do arithmetic calculations in bash script.</p>
<p><code>if [[ n -eq 42 ]]</code><br>Check <a href="http://mywiki.wooledge.org/BashFAQ/031" target="_blank" rel="noopener">Test</a> for different test conditions syntax in bash.</p>
<p><code>&quot;$?&quot;</code> Refers the exit code from last command.<br>Check <a href="https://www.gnu.org/software/bash/manual/html_node/Special-Parameters.html" target="_blank" rel="noopener">Special Variables</a> in bash.</p>
<ol start="4">
<li><p>As we covered in lecture <code>find</code>‘s <code>-exec</code> can be very powerful for performing operations over the files we are searching for.<br>However, what if we want to do something with <strong>all</strong> the files, like creating a zip file?<br>As you have seen so far commands will take input from both arguments and STDIN.<br>When piping commands, we are connecting STDOUT to STDIN, but some commands like <code>tar</code> take inputs from arguments.<br>To bridge this disconnect there’s the <a href="http://man7.org/linux/man-pages/man1/xargs.1.html" target="_blank" rel="noopener"><code>xargs</code></a> command which will execute a command using STDIN as arguments.<br>For example <code>ls | xargs rm</code> will delete the files in the current directory.</p>
<p> Your task is to write a command that recursively finds all HTML files in the folder and makes a zip with them. Note that your command should work even if the files have spaces (hint: check <code>-d</code> flag for <code>xargs</code>)</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> find . -<span class="built_in">type</span> f -name <span class="string">"*.html"</span> | xargs -d <span class="string">'\n'</span>  tar -cvzf</span></span><br><span class="line">  archive.tar.gz</span><br></pre></td></tr></table></figure>
</li>
<li><p>(Advanced) Write a command or script to recursively find the most recently modified file in a directory. More generally, can you list all files by recency?</p>
</li>
</ol>
<p>Here is one of the answer from <a href="https://stackoverflow.com/questions/5566310/how-to-recursively-find-and-list-the-latest-modified-files-in-a-directory-with-s" target="_blank" rel="noopener">here</a>.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">find <span class="variable">$1</span> -<span class="built_in">type</span> f -<span class="built_in">exec</span> <span class="built_in">stat</span> --format <span class="string">'%Y :%y %n'</span> <span class="string">"&#123;&#125;"</span> \; | sort -nr | cut -d: -f2- | head -n1</span><br></pre></td></tr></table></figure>
<p>Notes:</p>
<p><code>sort -nr</code> only sorted by lexical order, but because now the lexical order matches the time order, we can use in this way.</p>
]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>tool</tag>
        <tag>shell</tag>
        <tag>bash</tag>
      </tags>
  </entry>
  <entry>
    <title>[Missing Semester in CS] Shell</title>
    <url>/2020/04/01/MSC-shell/</url>
    <content><![CDATA[<p>The first class introduces the terminal shell, and they mainly focus on Bash since it is the default in most platform. </p>
<a id="more"></a>

<h2 id="Brief"><a href="#Brief" class="headerlink" title="Brief"></a>Brief</h2><p>It is perfect for the beginners without any knowledge of shell. Starting from terminal basics to some basic commands in bash such as <code>echo</code> and <code>ls</code>, the class provides enough information for anyone to start to explore the shell system (I guess <code>man</code> is enough to start …). </p>
<p>After going through the video and texts, we still need to figure out how to use more commands in order to grasp the basics of temrinal. I guess the most important experience for me is to search <strong>only when you need it</strong>. There are tons of commands to know if we want them all, and each commands has tons of options to explore. It turns to be extremely boring for me if I learn by reading A-Z exhausitive reference of shell commands. If you want to know how to find a file, then you learn <code>find</code>, and if you need to change a batch of files’ names, you get to know <code>for loop</code> and probably <code>sed</code>.</p>
<p>Another thing that might be helpful is, there are always many ways to finish one target. If you don’t like the top answer from <a href="https://stackoverflow.com/" target="_blank" rel="noopener">StackOverflow</a>, maybe the second one or some comments might attract you.</p>
<h2 id="Exercise"><a href="#Exercise" class="headerlink" title="Exercise"></a>Exercise</h2><ol>
<li>Create a new directory called <code>missing</code> under <code>/tmp</code>. </li>
</ol>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> /tmp </span></span><br><span class="line"><span class="meta">$</span><span class="bash"> mkdir missing</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>Look up the <code>touch</code> program. The <code>man</code> program is your friend. </li>
</ol>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> man touch</span></span><br></pre></td></tr></table></figure>
<p>Here is a <a href="https://unix.stackexchange.com/questions/109003/what-are-the-legitimate-uses-of-the-touch-command" target="_blank" rel="noopener">link</a> about discussion<br>of how to use touch. Except create a new file, it can change the<br>timestep to accomplish interesting task.</p>
<ol start="3">
<li>Use <code>touch</code> to create a new file called <code>semester</code> in <code>missing</code>.</li>
</ol>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> touch semester</span></span><br></pre></td></tr></table></figure>

<ol start="4">
<li>Write the following into that file, one line at a time:<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line">curl --head --silent https://missing.csail.mit.edu</span><br></pre></td></tr></table></figure>
The first line might be tricky to get working. It’s helpful to know that<br><code>#</code> starts a comment in Bash, and <code>!</code> has a special meaning even within<br>double-quoted (<code>&quot;</code>) strings. Bash treats single-quoted strings (<code>&#39;</code>)<br>differently: they will do the trick in this case. See the Bash<br><a href="https://www.gnu.org/software/bash/manual/html_node/Quoting.html" target="_blank" rel="noopener">quoting</a><br>manual page for more information.</li>
</ol>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> \<span class="comment">#\!/bin/sh  &gt; semester</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="string">"curl --head --silent https://missing.csail.mit.edu"</span> &gt;&gt; semester</span></span><br></pre></td></tr></table></figure>
<p>What if we want to add these line at the beginning of the file? Here are<br>some <a href="https://superuser.com/questions/246837/how-do-i-add-text-to-the-beginning-of-a-file-in-bash" target="_blank" rel="noopener">solutions</a>.</p>
<ol start="5">
<li>Try to execute the file, i.e. type the path to the script (<code>./semester</code>)<br> into your shell and press enter. Understand why it doesn’t work by<br> consulting the output of <code>ls</code> (hint: look at the permission bits of the<br> file).</li>
</ol>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ls -l semester</span></span><br><span class="line">-rw-r--r-- 1 hcwang hcwang 51 Apr  1 23:35 semester</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>Run the command by explicitly starting the <code>sh</code> interpreter, and giving it<br> the file <code>semester</code> as the first argument, i.e. <code>sh semester</code>. Why does<br> this work, while <code>./semester</code> didn’t?</li>
</ol>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sh semester </span></span><br><span class="line">HTTP/2 200 </span><br><span class="line">server: GitHub.com</span><br><span class="line">content-type: text/html; charset=utf-8</span><br><span class="line">......</span><br><span class="line">content-length: 6845</span><br></pre></td></tr></table></figure>
<p>Why is that? When use <code>sh</code>, the system will call <code>dash</code> interpreter to <strong>read</strong> the file <code>semester</code>, where the reading is permitted. While <code>./semester</code> directly <strong>execute</strong> the file which does not has execution permission.</p>
<ol start="7">
<li><p>Look up the <code>chmod</code> program (e.g. use <code>man chmod</code>).</p>
</li>
<li><p>Use <code>chmod</code> to make it possible to run the command <code>./semester</code> rather than<br> having to type <code>sh semester</code>. How does your shell know that the file is<br> supposed to be interpreted using <code>sh</code>? See this page on the<br> <a href="https://en.wikipedia.org/wiki/Shebang_(Unix)" target="_blank" rel="noopener">shebang</a> line for more<br> information.</p>
</li>
</ol>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> chmod u+x semester</span></span><br></pre></td></tr></table></figure>

<ol start="9">
<li><p>Use <code>|</code> and <code>&gt;</code> to write the “last modified” date output by<br><code>semester</code> into a file called <code>last-modified.txt</code> in your home<br>directory.</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ./semester | grep <span class="string">"last modified"</span> &gt; last-modified.txt</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>Write a command that reads out your laptop battery’s power level or your<br>desktop machine’s CPU temperature from <code>/sys</code>. Note: if you’re a macOS<br>user, your OS doesn’t have sysfs, so you can skip this exercise.</p>
</li>
</ol>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># for energy</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> cat /sys/class/power_supply/BAT0/energy_now</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> cat /sys/class/power_supply/BAT0/energy_full_design</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> cat /sys/class/power_supply/BAT0/energy_full</span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># for cpu temperature</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> cat /sys/devices/platform/coretemp.0/hwmon/hwmon?/temp*</span></span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>tool</tag>
        <tag>shell</tag>
        <tag>bash</tag>
      </tags>
  </entry>
  <entry>
    <title>Documentation of Hexo</title>
    <url>/2020/04/01/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. For problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<a id="more"></a>

<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>
]]></content>
      <categories>
        <category>Blog</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Missing Semester for CS</title>
    <url>/2020/03/30/missing-semester/</url>
    <content><![CDATA[<p>The <a href="https://missing.csail.mit.edu/" target="_blank" rel="noopener">Missing Sememster of CS degree</a> is actually the missing one for my coursework in CS degree. It is a good chance for anyone who has a CS degree to brush up his or her idea about tools behind the Computer Science. Absolutely it would be the perfect course for students who are now learning CS.</p>
<a id="more"></a>

<p>Here is the course structure, they cover a bunch of useful tools that are indeed beneficial to our development journey.</p>
<h2 id="Course-Structure"><a href="#Course-Structure" class="headerlink" title="Course Structure"></a>Course Structure</h2><ul>
<li>Shell</li>
<li>Vim</li>
<li>Data manipulation</li>
<li>Commandline environment</li>
<li>Git</li>
<li>Debuging, logging, profiling</li>
<li>Makefiles</li>
<li>Security</li>
<li>Miscellaneous</li>
</ul>
<h2 id="Motivation"><a href="#Motivation" class="headerlink" title="Motivation"></a>Motivation</h2><p>Now I am using vim to write the post. Although sometimes it took me a bit longer to edit, I feel I am doing faster and better. As the instructor in the course showed, <strong>it should take about 20 hours for us to get back the editing speed in a new editor</strong>. After 20 hours, every minute faster is the actual gain. </p>
<p>Beside the speed increasing, using “hacker” tool may help us to code in a positive way: explore and learn to reduce repetitive actions. I guess that is the biggest reason that we use computer. Computers save us already great amount of time, but there are way more to save! I can feel that there are still a lot redundant and repetitve actions during the development, and that is the motivation for more tools to come. For us, it is the first step to keep searching and practicing the useful tools, breaking the fear of steep learning curve. It is the first 20 hours that hinges us to the more productive and hacking work style.</p>
<p>Here is the <a href="https://missing.csail.mit.edu/about/" target="_blank" rel="noopener">motivation</a> from the course instructor, maybe one will get a more interesting point from there.</p>
<p>Anyway, I will try to start. As a concrete action, I will post following up posts to finish the exercises in the course, and hopefully find more useful resources to add.</p>
]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>tool</tag>
      </tags>
  </entry>
</search>
